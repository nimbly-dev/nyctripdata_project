{% set year_month = var("year_month", "2021_12") %}
{% set parts = year_month.split('_') %}
{% set year = parts[0] | int %}
{% set month = parts[1] | int %}
{% set next_month = month + 1 %}
{% set next_year = year %}
{% if next_month > 12 %}
  {% set next_year = year + 1 %}
  {% set next_month = 1 %}
{% endif %}
{% set partition_start = ("%04d-%02d-01" % (year, month)) %}
{% set partition_end = ("%04d-%02d-01" % (next_year, next_month)) %}

-- Dynamically resolve schema and table names
{% set target_schema = target.schema ~ '_fact' %}
{% set table_name = this.identifier %}

{% do log("DEBUG: target_schema is " ~ target_schema, info=True) %}
{% do log("DEBUG: table_name is " ~ table_name, info=True) %}

{% set csv_path = "/tmp/temp_copy/combined/" ~ year_month ~ "/combined_" ~ year_month ~ ".csv" %}
{% set copy_command = "COPY " ~ target_schema ~ '.' ~ table_name ~ " FROM '" ~ csv_path ~ "' WITH CSV HEADER;" %}

-- Reference the combined_clean_cab_tripdata table correctly (FROM staging)
{% set combined_relation = target.schema ~ '."combine_clean_cab_tripdata"' %}

-- Define the query for remote data extraction
{% set remote_query %}
SELECT 
    dwid, cab_type, fare_amount, total_amount, trip_distance, vendor_id, 
    ratecode_id, pu_location_id, do_location_id, pickup_datetime, dropoff_datetime, 
    payment_type, dispatching_base_num, affiliated_base_number 
FROM {{ combined_relation }}
{% endset %}

-- Define the column types
{% set column_definitions %}
dwid TEXT, cab_type TEXT, fare_amount REAL, total_amount REAL, 
trip_distance REAL, vendor_id INT, ratecode_id INT, pu_location_id INT, 
do_location_id INT, pickup_datetime TIMESTAMP, dropoff_datetime TIMESTAMP, 
payment_type INT, dispatching_base_num VARCHAR, affiliated_base_number VARCHAR
{% endset %}

-- Safe deletion of previous partitioned data
{% set delete_stmt %}
DO $$ 
DECLARE 
    schema_name TEXT := '{{ target_schema }}';
    tbl_name TEXT := '{{ table_name }}';
BEGIN
    IF EXISTS (
        SELECT 1 FROM pg_tables 
        WHERE schemaname = schema_name AND tablename = tbl_name
    ) THEN
        EXECUTE format('DELETE FROM %I.%I WHERE to_char(pickup_datetime, ''YYYY_MM'') = %L', 
            schema_name, tbl_name, '{{ year_month }}');
    END IF;
END $$;
{% endset %}

-- Create partition table for new month
{% set partition_stmt %}
DO $$ 
DECLARE 
    schema_name TEXT := '{{ target_schema }}';
    tbl_name TEXT := '{{ table_name }}';
    partition_name TEXT := tbl_name || '_{{ year_month }}';
    part_start DATE := '{{ partition_start }}'::DATE;
    part_end DATE := '{{ partition_end }}'::DATE;
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = schema_name AND table_name = partition_name
    ) THEN
        EXECUTE format('CREATE TABLE %I.%I PARTITION OF %I.%I FOR VALUES FROM (%L) TO (%L)', 
            schema_name, partition_name, schema_name, tbl_name, part_start, part_end);
    END IF;
END $$;
{% endset %}

{{ 
    config(
        materialized='incremental',
        unique_key='dwid',
        schema=target_schema,
        partition_by={
            "field": "pickup_datetime",
            "data_type": "date",
            "granularity": "month"
        },
        on_schema_change="sync_all_columns",
        pre_hook=[
            delete_stmt,
            partition_stmt,
            export_data_to_csv(remote_query, 'combined', year_month, column_definitions)
        ],
        post_hook=copy_command
    )
}}

-- Final Query: Incremental Logic
SELECT *
FROM {{ this }}
{% if is_incremental() %}
  WHERE pickup_datetime > (SELECT MAX(pickup_datetime) FROM {{ this }})
{% endif %}